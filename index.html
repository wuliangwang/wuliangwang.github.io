<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>wuliangwang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="wuliangwang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="wuliangwang">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wuliangwang">
  
    <link rel="alternate" href="/atom.xml" title="wuliangwang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">wuliangwang</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS - 人脸特征关键点获取" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/25/iOS - 人脸特征关键点获取/" class="article-date">
  <time datetime="2018-04-24T16:00:00.000Z" itemprop="datePublished">2018-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/25/iOS - 人脸特征关键点获取/">iOS - 人脸特征关键点获取</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-OpenCV-Face-stasm"><a href="#1-OpenCV-Face-stasm" class="headerlink" title="1. OpenCV + Face + stasm"></a>1. OpenCV + Face + stasm</h3><p><code>OpenCV</code>  OpenCV3.0以上的包</p>
<p> <code>Face</code> 是指的是OpenCV的拓展包,iOS没有直接集成. 需要收到打包成静态库文件使用</p>
<p><code>stasm</code>是一个已经写好的c++算法，用来获取人脸信息，依赖于OpenCV.</p>
<p>1.1.1    首先先从OpenCV的官网将OpenCV的包下载下来,<a href="https://opencv.org/" target="_blank" rel="noopener">下载地址</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3111822-7ccf6b964fd9360d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载解压完成后"></p>
<p>1.1.2 将OpenCV的拓展包下载下来, <a href="https://github.com/opencv/opencv_contrib" target="_blank" rel="noopener">下载地址</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3111822-49bbd6e97abd7dcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拓展包下载解压完成后"></p>
<p>1.1.3 stasm 算法的下载 <a href="https://github.com/wuliangwang/Face/tree/master/Tool" target="_blank" rel="noopener">下载地址</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3111822-2bab80072b404b10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="stasm 算法"></p>
<p>三个文件都下载完成之后，开始合并 OpenCV 的静态库</p>
<p>1.2.1 将OpenCV的拓展包 opencv_contrib-master 下的 modules 目录下的所有文件copy到 OpenCV包目录下的modules中.</p>
<p>1.2.2 文件copy完成后，这个时候打开终端 cd 到 OpenCV包目录下 platforms -&gt;  ios 下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3111822-95d918d29bb031e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="platforms -&gt;  ios 下"></p>
<p>1.2.3 执行 <code>build_framework.py</code>  文件, 这是一个python文件，mac自带了python2.7的环境，所有可以执行</p>
<p>执行命令 <code>python build_framework.py</code> (需要确保在上述路径下,否则会找不到这个文件)</p>
<p>1.2.4 执行该脚本耗时很长，所有执行前需要确保 已经将拓展包中modules目录下的文件copy到了OpenCV -&gt; modules 目录下</p>
<p>1.2.5 执行成功， 经过漫长的等待后, 该目录下生成了一个 build的文件夹，该文件夹目录下就有已经打包好的OpenCV静态库的包，拉进项目 可以直接使用.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3111822-dae9273daed664c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build"></p>
<p>1.3.1 在Xcode 中使用 stasm 算法获取 人脸关键点信息</p>
<p>先配置好 stasm 算法中需要的训练库(之前下载链接中有)</p>
<p>在 stasm-&gt;MOD_1 -&gt;facedet.cpp -&gt; OpenFaceDetector_ 方法中 正脸目前测试 haarcascade_frontalface_alt2 效果最佳</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3111822-61b3fb41f946797f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="训练库设置"></p>
<p>使用 (因为是C++的方法 所以需要改为.mm 使用)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int stasm_search_single(   // wrapper for stasm_search_auto and friends</span><br><span class="line">    int*        foundface, // out: 0=no face, 1=found face</span><br><span class="line">    float*      landmarks, // out: x0, y0, x1, y1, ..., caller must allocate</span><br><span class="line">    const char* img,       // in: gray image data, top left corner at 0,0</span><br><span class="line">    int         width,     // in: image width</span><br><span class="line">    int         height,    // in: image height</span><br><span class="line">    const char* imgpath,   // in: image path, used only for err msgs and debug</span><br><span class="line">    const char* datadir)   // in: directory of face detector files</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	配置参数</span><br><span class="line"> *	参数1: 表示是否成功  0=no face, 1=found face</span><br><span class="line"> *	参数2: 成功后 获取的关键点位置</span><br><span class="line"> *	参数3: 图片的灰度图的二进制值</span><br><span class="line"> *	参数4/5: 图片的宽高值</span><br><span class="line"> *  参数6: 图片路径 调试用 可以不传</span><br><span class="line"> *  参数7: 训练库文件的目录 注意只是到当前目录 不是全路径</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 参数1</span><br><span class="line">int foundface;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 参数2</span><br><span class="line"> * stasm_NLANDMARKS 是 stasm的一个宏 一个int值 值为77 表示可以获取到77个点</span><br><span class="line"> * 乘以2 是因为返回的值是float 每一个点都有x,y 返回值为:x0, y0, x1, y1, 相当于两个元素才能合成一个点</span><br><span class="line"> */</span><br><span class="line">float landmarks[2 * stasm_NLANDMARKS];</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 参数3</span><br><span class="line"> * 图片的灰度图, 可以直接使用OpenCV的方法获取</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 将UIImage 转成 cv::Mat </span><br><span class="line">cv::Mat cvFaceImage;</span><br><span class="line">UIImageToMat(image, cvFaceImage);</span><br><span class="line"></span><br><span class="line">// 将cv::Mat的image 转成灰度图</span><br><span class="line">// CV_RGBA2GRAY 表示 将四通道RGBA的图片 转成灰度图 iOS中图片默认是RGBA的</span><br><span class="line">cv::Mat cvGrayFaceImage;</span><br><span class="line">cv::cvtColor(cvFaceImage, cvGrayFaceImage,CV_RGBA2GRAY);</span><br><span class="line">const char* imgData = (const char*)cvGrayFaceImage.data;</span><br><span class="line"></span><br><span class="line">//参数4/5 图片的宽高 cv::Mat 的图片可以直接取</span><br><span class="line">int imgCols = cvGrayFaceImage.cols;</span><br><span class="line">int imgRows = cvGrayFaceImage.rows;</span><br><span class="line"></span><br><span class="line">// 参数6 不传</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 参数7 训练库文件的目录 </span><br><span class="line"> * 这里需要注意 iOS获取项目中文件 需要通过Bundle获取</span><br><span class="line"> * [NSBundle mainBundle].bundlePath 作为目录 是可以拿到项目中所以文件的 不管有没有其他子文件夹了。</span><br><span class="line"> * 其他平台中, 那么就指定路径</span><br><span class="line"> */</span><br><span class="line"> const char *xmlPath = [[NSBundle mainBundle].bundlePath UTF8String];</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">// 方法有返回值 如果为0 那么就说明方法调用出现问题</span><br><span class="line">int stasmActionError = stasm_search_single(&amp;foundface, landmarks,imgData, imgCols, imgRows, &quot;&quot;, xmlPath);</span><br><span class="line">if (!stasmActionError)&#123;</span><br><span class="line">   	//  通过打印 stasm_lasterr() 可以看到错误信息</span><br><span class="line">    printf(&quot;Error in stasm_search_single: %s\n&quot;, stasm_lasterr());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!foundface) &#123;</span><br><span class="line">	printf(&quot;No face found&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    // 这里就说明已经获取到关键点了 </span><br><span class="line">    // 将关键点显示出来</span><br><span class="line">    </span><br><span class="line">   // 将RGBA四通道的图片 转成 BGR三通道</span><br><span class="line">   cv::Mat cvFaceImage_BGR;</span><br><span class="line">   cv::cvtColor(cvFaceImage, cvFaceImage_BGR, CV_RGBA2BGR);</span><br><span class="line">   </span><br><span class="line">   for (int i = 0; i &lt; stasm_NLANDMARKS; i++)&#123;</span><br><span class="line">   		// 生成一个当前点脚标的String字符串</span><br><span class="line">        std::string number = std::to_string(i);</span><br><span class="line">        // 获取中心点 根据x在前 y在后 两个元素为一个点的顺序</span><br><span class="line">        cv::Point center(cvRound(landmarks[i * 2 ]), cvRound(landmarks[i * 2+1]));</span><br><span class="line">        // 将点画上去 </span><br><span class="line">        cv::circle(cvFaceImage_BGR, center, 0.25, cv::Scalar(255, 0, 0), 2, 8, 0);</span><br><span class="line">        // 将脚标也画上去</span><br><span class="line">        cv::putText(cvFaceImage_BGR,number,center, cv::FONT_HERSHEY_PLAIN,0.7, cv::Scalar(0, 0, 255));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   // 将BGR三通道的图片 转成 RGBA四通道</span><br><span class="line">   cv::Mat cvFaceImageResult;</span><br><span class="line">   cv::cvtColor(cvFaceImage_BGR, cvFaceImageResult, CV_BGR2RGBA);</span><br><span class="line">    </span><br><span class="line">   //绘制出关键点的image</span><br><span class="line">   UIImage *result = MatToUIImage(cvFaceImageResult);</span><br><span class="line">   </span><br><span class="line">   cvFaceImage_BGR.release();</span><br><span class="line">   cvFaceImageResult.release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放cv::Mat</span><br><span class="line">cvFaceImage.release();</span><br><span class="line">cvGrayFaceImage.release();</span><br></pre></td></tr></table></figure>
<p> 关于  cv::circle 和 cv::putText</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* 绘制圆形</span><br><span class="line"> * img: cv::Mat的 image， 注意 这里需要转成三通道BGR的图片, 因为OpenCV中用的是这种格式 </span><br><span class="line"> * center: 中心点</span><br><span class="line"> * radius: 半径</span><br><span class="line"> * color: 颜色 创建方法 cv::Scalar(B, G, R);</span><br><span class="line"> * thickness: 如果是正数，表示组成圆的线条的粗细程度。否则，表示圆是否被填充</span><br><span class="line"> * lineType： 线条类型 正常用  LINE_8 / 8 就OK</span><br><span class="line"> 	* FILLED  = -1, </span><br><span class="line">    * LINE_4  = 4, //!&lt; 4-connected line</span><br><span class="line">    * LINE_8  = 8, //!&lt; 8-connected line</span><br><span class="line">    * LINE_AA = 16 //!&lt; antialiased line</span><br><span class="line"> * shift: 圆心坐标点和半径值的小数点位数 也就是说中心点和半径的值的精度化</span><br><span class="line"> */</span><br><span class="line"> void circle(InputOutputArray img, Point center, int radius,</span><br><span class="line">                       const Scalar&amp; color, int thickness = 1,</span><br><span class="line">                       int lineType = LINE_8, int shift = 0);</span><br><span class="line">                       </span><br><span class="line">                       </span><br><span class="line"></span><br><span class="line">/* 绘制文字</span><br><span class="line"> * img: cv::Mat的 image， 注意 这里需要转成三通道BGR的图片, 因为OpenCV中用的是这种格式 </span><br><span class="line"> * text: 待显示的文字</span><br><span class="line"> * org: 文字在图像中的左下角 坐标.</span><br><span class="line"> * fontFace: 字体类型，</span><br><span class="line"> 	* 可选择字体：FONT_HERSHEY_SIMPLEX, FONT_HERSHEY_PLAIN, 			FONT_HERSHEY_DUPLEX,FONT_HERSHEY_COMPLEX, FONT_HERSHEY_TRIPLEX, FONT_HERSHEY_COMPLEX_SMALL, FONT_HERSHEY_SCRIPT_SIMPLEX, orFONT_HERSHEY_SCRIPT_COMPLEX,以上所有类型都可以配合 FONT_HERSHEY_ITALIC使用，产生斜体效果。	</span><br><span class="line"> * fontScale: 字体大小，该值和字体内置大小相乘得到字体大小</span><br><span class="line"> * color: 颜色 创建方法 cv::Scalar(B, G, R);</span><br><span class="line"> * thickness: 写字的线的粗细，类似于0.38的笔尖和0.5的笔尖</span><br><span class="line"> * lineType： 写字的线条类型 和上诉一致</span><br><span class="line"> * bottomLeftOrigin: true: 图像数据原点在左下角. false: 图像数据原点在左上角.</span><br><span class="line"> */</span><br><span class="line">void putText( InputOutputArray img, const String&amp; text, Point org,</span><br><span class="line">                         int fontFace, double fontScale, Scalar color,</span><br><span class="line">                         int thickness = 1, int lineType = LINE_8,</span><br><span class="line">                         bool bottomLeftOrigin = false )</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/3111822-f3a41a525e41b425.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OpenCV效果图"></p>
<p>优点: 基于OpenCV + 拓展包, 效率快,  正面点精确率高. 免费.市面上大厂提供的SDK基本都是收费的.</p>
<p>缺点:  OpenCV + 拓展包合并出来的静态库文件太大,  不适合在APP上面.</p>
<p>有一个缩小的方法: 不使用拓展包的face模块， 直接使用OpenCV中的objdetect模块. 效果差不多,就是效率低了很多. </p>
<p>缩小版使用方法: </p>
<p>直接Pod OpenCV2 大于3.0版本. 或者直接去官网下载一个OpenCV的包 也要大于3.0， 然后不用 上述 1.2.1 那一步， 直接去执行脚本文件,生成一个OpenCV的静态库.</p>
<p>然后将 stasm 目录下所有文件 导入 <code>include &lt;opencv2/face.hpp&gt;</code> 的代码换成 <code>include &lt;opencv2/objdetect.hpp&gt;</code> 就OK了. 其他使用步骤方法和上述一致.</p>
<p>注意点: 因为OpenCV中有一些宏定义和系统的冲突， 所以OpenCV的头文件导入, 需要在最前面, 否则会报错.</p>
<p><a href="https://github.com/wuliangwang/Face/tree/master/GetPoint" target="_blank" rel="noopener">方法获取</a></p>
<h3 id="2-iOS11-原生框架-Vision"><a href="#2-iOS11-原生框架-Vision" class="headerlink" title="2. iOS11 原生框架 Vision"></a>2. iOS11 原生框架 Vision</h3><blockquote>
<p>Vision 是 Apple 在 WWDC 2017 推出的图像识别框架。</p>
<p><strong>Vison 的设计理念</strong></p>
<p>苹果最擅长的，把复杂的事情简单化，Vision的设计理念也正是如此。</p>
<p>对于使用者我们抽象的来说，我们只需要：提出问题–&gt;经过机器–&gt;得到结果。</p>
<p>开发者不需要是计算机视觉专家，开发者只需要得到结果即可，一切复杂的事情交给Vision。</p>
</blockquote>
<p>Vision 获取人脸信息 使用</p>
<p>1，创建处理图片处理对应的VNImageRequestHandler对象。</p>
<p>2， 创建对应的识别 VNDetectFaceLandmarksRequest 请求，指定 Complete Handler 识别成功后进行回调执行的一个Block）</p>
<p>3，发送识别请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Vision/Vision.h&gt;</span><br><span class="line">//1</span><br><span class="line">CIImage *faceCIImage = [[CIImage alloc]initWithImage:image];</span><br><span class="line">VNImageRequestHandler *vnRequestHeader = [[VNImageRequestHandler alloc] initWithCIImage:faceCIImage options:@&#123;&#125;];</span><br><span class="line">//2</span><br><span class="line">__weak ViewController *weakSelf = self;</span><br><span class="line">VNDetectFaceLandmarksRequest *faceRequest = [[VNDetectFaceLandmarksRequest alloc] initWithCompletionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) &#123;</span><br><span class="line">	[weakSelf faceLandmarks:request.results];</span><br><span class="line">&#125;];</span><br><span class="line">// 3</span><br><span class="line">[vnRequestHeader performRequests:@[face_request] error:NULL];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取信息成功后 处理</span><br><span class="line">- (void)faceLandmarks:(NSArray *)faces&#123;</span><br><span class="line">    // 可能是多张脸</span><br><span class="line">    [faces enumerateObjectsUsingBlock:^(VNFaceObservation *face, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">       </span><br><span class="line">       /*</span><br><span class="line">       	* face: VNFaceObservation 对象, 里面包含了 landmarks 位置信息, boundingBox 脸的大小 等等信息</span><br><span class="line">        */</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       	// 取出单个脸的 landmarks </span><br><span class="line">        VNFaceLandmarks2D *landmarks = face.landmarks;</span><br><span class="line">        // 声明一个存关键位置的数组</span><br><span class="line">        NSMutableArray *face_landmarks = [NSMutableArray array];</span><br><span class="line">        </span><br><span class="line">        // landmarks 是一个对象，对象中有左眼位置，右眼，鼻子，鼻梁等等属性 根据需求自己添加</span><br><span class="line">        [face_landmarks addObject:landmarks.faceContour];</span><br><span class="line">        [face_landmarks addObject:landmarks.leftEye];</span><br><span class="line">        [face_landmarks addObject:landmarks.rightEye];</span><br><span class="line">        [face_landmarks addObject:landmarks.leftEyebrow];</span><br><span class="line">        [face_landmarks addObject:landmarks.rightEyebrow];</span><br><span class="line">        [face_landmarks addObject:landmarks.outerLips];</span><br><span class="line">        [face_landmarks addObject:landmarks.innerLips];</span><br><span class="line">        [face_landmarks addObject:landmarks.nose];</span><br><span class="line">        [face_landmarks addObject:landmarks.noseCrest];</span><br><span class="line">        [face_landmarks addObject:landmarks.medianLine];</span><br><span class="line">        [face_landmarks addObject:landmarks.outerLips];</span><br><span class="line">        [face_landmarks addObject:landmarks.innerLips];</span><br><span class="line">        [face_landmarks addObject:landmarks.leftPupil];</span><br><span class="line">        [face_landmarks addObject:landmarks.rightPupil];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // 当前脸在图片中的位置和大小</span><br><span class="line">        // 注意: boundingBox 返回的x,y,w,h 的比例 不是直接的值，所以需要转换</span><br><span class="line">        </span><br><span class="line">        // 这里的 image_wh是一个宏 表示的图片的宽高大小 也可以直接image.size.width....</span><br><span class="line">        </span><br><span class="line">        CGFloat faceRectWidth = image_wh * face.boundingBox.size.width;</span><br><span class="line">        CGFloat faceRectHeight = image_wh * face.boundingBox.size.height;</span><br><span class="line">        CGFloat faceRectX = face.boundingBox.origin.x * image_wh;</span><br><span class="line">        // Y默认的位置是左下角</span><br><span class="line">        CGFloat faceRectY = face.boundingBox.origin.y * image_wh;</span><br><span class="line">        </span><br><span class="line">  		// 遍历位置信息</span><br><span class="line">        [face_landmarks enumerateObjectsUsingBlock:^(VNFaceLandmarkRegion2D *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        	// VNFaceLandmarkRegion2D *obj 是一个对象. 表示当前的一个部位</span><br><span class="line">			// 遍历当前部分所有的点</span><br><span class="line">            for (int i=0; i&lt;obj.pointCount; i++) &#123;</span><br><span class="line">            	// 取出点</span><br><span class="line">                CGPoint point = obj.normalizedPoints[i];</span><br><span class="line">                </span><br><span class="line">                // 计算出center</span><br><span class="line">                /*</span><br><span class="line">                 * 这里的 point 的 x,y 表示也比例, 表示当前点在脸的比例值</span><br><span class="line">                 * 因为Y点是在左下角， 所以我们需要转换成左上角</span><br><span class="line">                 * 这里的center 关键点 可以根据需求保存起来</span><br><span class="line">                 */</span><br><span class="line">        		CGPoint center = CGPointMake(faceRectX + faceRectWidth * point.x, image_wh - (faceRectY + faceRectHeight * point.y));</span><br><span class="line">               </span><br><span class="line">                // 将点显示出来</span><br><span class="line">                UIView *point_view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 3, 3)];</span><br><span class="line">                point_view.backgroundColor = [UIColor redColor];</span><br><span class="line">                point_view.center = center;                </span><br><span class="line">                // 将点添加到imageView上即可 需要注意，当前image的bounds 应该和图片大小一样大</span><br><span class="line">                [imageView addSubview:point_view];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/3111822-45ad1bd1fcd8054d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单脸效果"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3111822-4cd278a81e125d9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多脸效果"></p>
<p>多脸效果 因为图片设置的小 所以有点密 </p>
<p>关于Vision 这里有一篇其他文章推荐 <a href="http://www.cocoachina.com/ios/20170801/20061.html" target="_blank" rel="noopener">Vision </a></p>
<p><strong>优点</strong>: 苹果原生,使用方便,多脸识别. 免费, 不需要联网<br><strong>缺点</strong>: iOS11 以上才能使用. 精确率不如OpenCV</p>
<h3 id="3-腾讯优图SDK"><a href="#3-腾讯优图SDK" class="headerlink" title="3.腾讯优图SDK"></a>3.腾讯优图SDK</h3><p>典型案例: 天天P图 </p>
<blockquote>
<p>对请求图片进行五官定位，计算构成人脸轮廓的90个点，包括眉毛（左右各8点）、眼睛（左右各8点）、鼻子（13点）、嘴巴（22点）、脸型轮廓（21点）、眼珠[或瞳孔]（2点）。<br><img src="https://upload-images.jianshu.io/upload_images/3111822-71956960213666c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优图示范效果图"></p>
</blockquote>
<p><a href="http://open.youtu.qq.com/#/develop/api-face-analysis-shape" target="_blank" rel="noopener">优图SDK</a><br><a href="https://github.com/Tencent-YouTu/ios_sdk" target="_blank" rel="noopener">工具包下载</a></p>
<p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//1. 注册sdk 需要Conf.m 文件中 填写  appId ,secretId, secretKey</span><br><span class="line">NSString *auth = [Auth appSign:1000000 userId:nil];</span><br><span class="line">TXQcloudFrSDK *sdk = [[TXQcloudFrSDK alloc] initWithName:[Conf instance].appId authorization:auth endPoint:[Conf instance].API_END_POINT];</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * TXQcloudFrSDK 中有很多方法 人脸检测，人脸对比等等.. 用法都一样，直接请求 参数类型不一致，详见TXQcloudFrSDK.h</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 2 发送请求获取关键点</span><br><span class="line"> [sdk faceShape:image successBlock:^(id responseObject) &#123;</span><br><span class="line"> // 该方法 responseObject 是一个字典</span><br><span class="line">  [self handleFacePoint:responseObject];</span><br><span class="line"> &#125; failureBlock:^(NSError *error) &#123;</span><br><span class="line">  NSLog(@&quot;error : %@&quot;,error);</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line">// 3 处理关键点信息</span><br><span class="line"></span><br><span class="line">- (void)handleFacePoint:(NSDictionary *)responseObject&#123;</span><br><span class="line">    // 将人脸信息提取出来</span><br><span class="line">    NSArray * face_shape = [responseObject objectForKey:@&quot;face_shape&quot;];</span><br><span class="line">    if (face_shape.count == 0) &#123;</span><br><span class="line">        NSLog(@&quot;没有找到脸的位置&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSDictionary *face_shape_first = [face_shape firstObject];</span><br><span class="line">    [face_shape_first enumerateKeysAndObjectsUsingBlock:^(NSString *key, NSArray * obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        NSLog(@&quot;位置 %@&quot;,key);</span><br><span class="line">        [obj enumerateObjectsUsingBlock:^(NSDictionary *dict, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">            NSLog(@&quot;x: %@  Y: %@&quot;,[dict objectForKey:@&quot;x&quot;],[dict objectForKey:@&quot;y&quot;]);</span><br><span class="line">            // 这里获取到的点 是直接匹配上传图片对应位置的， 不需要二次转换</span><br><span class="line">            CGFloat x = [[dict objectForKey:@&quot;x&quot;] doubleValue];</span><br><span class="line">            CGFloat y = [[dict objectForKey:@&quot;y&quot;] doubleValue];</span><br><span class="line">         </span><br><span class="line">            UIView *pointView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 3, 3)];</span><br><span class="line">            pointView.center = CGPointMake(x , y );</span><br><span class="line">            pointView.backgroundColor = [UIColor redColor];</span><br><span class="line">            [imageView addSubview:pointView];</span><br><span class="line">            </span><br><span class="line">        &#125;];</span><br><span class="line">        NSLog(@&quot;----&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3111822-c98b1d48e42fa632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优图SDK效果图"></p>
<h4 id="其他SDK-科大讯飞，百度，阿里，face-…-等等有很多大公司都提供了人脸信息获取的接口"><a href="#其他SDK-科大讯飞，百度，阿里，face-…-等等有很多大公司都提供了人脸信息获取的接口" class="headerlink" title="其他SDK, 科大讯飞，百度，阿里，face++…. 等等有很多大公司都提供了人脸信息获取的接口"></a>其他SDK, 科大讯飞，百度，阿里，face++…. 等等有很多大公司都提供了人脸信息获取的接口</h4><p>第三方SDK 优缺点<br><strong>优点:</strong> 集成方便,识别快, 精确率高。<br><strong>缺点:</strong> 收费,需要依赖网络请求. 也提供了本地识别的SDK,价格很高.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/25/iOS - 人脸特征关键点获取/" data-id="cjgeztz690005gwf9b8noor8z" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-cell_copy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/09/cell_copy/" class="article-date">
  <time datetime="2018-03-09T06:48:46.000Z" itemprop="datePublished">2018-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/09/cell_copy/">Cell自带的长按复制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>系统提供了 UITableViewCell 长按复制的代理方法，遵守实现即可。<br><img src="http://upload-images.jianshu.io/upload_images/3111822-81107944ab0650db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图1"></p>
<p>需要遵守 <code>UITableViewDelegate</code> 协议，并设置代理对象.</p>
<h5 id="1-设置哪一行显示。"><a href="#1-设置哪一行显示。" class="headerlink" title="1.设置哪一行显示。"></a>1.设置哪一行显示。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)tableView:(UITableView *)tableView shouldShowMenuForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">      return YES;// 设置哪里显示。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果指定 cell 才有该功能 通过<code>indexPath</code>判断下。返回 <strong>YES</strong> 表示可以显示。<strong>NO</strong>表示不显示。</p>
<p>#####2. 指定哪一行显示哪些操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 设置只有 section = 0 的cell 才能显示并且只有 copy 一个操作</span><br><span class="line">// 根据  action 和 indexPath 来决定哪行哪些操作可以显示</span><br><span class="line">- (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender &#123;</span><br><span class="line">    NSLog(@&quot;-------%@&quot;,NSStringFromSelector(action));</span><br><span class="line">    if(action == @selector(copy:) &amp;&amp; indexPath.section == 0)&#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该代理方法会多次调用来确定哪些操作可以显示, 我通过打印  action 发现了 <code>cut:、copy:、paste:、select:、selectAll: ....</code>一些操作, 但是当我全部返回YES时发现显示的只有<code>cut:、copy:、paste:</code> 这三个，并且当我设置这三个其中一个为NO时, <code>select:</code>或者其他非该三个 action 时 显示的就只有两个了，通过这样的测试我发现 可以显示的操作只有 <code>cut:、copy:、paste:</code>。如果是我的操作不对造成的这样的效果，欢迎在评论区提出，谢谢.<br><img src="http://upload-images.jianshu.io/upload_images/3111822-b5ad6a8d92e4e1b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="全部返回YES的效果"></p>
<p>#####3、执行操作，设置操作对应的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 长按选择操作后调用</span><br><span class="line">- (void)tableView:(UITableView *)tableView performAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender&#123;</span><br><span class="line">    // 根据 indexPath 和 action 来判定是不是对应的操作。</span><br><span class="line">    if (action == @selector(copy:)) &#123;</span><br><span class="line">        [UIPasteboard generalPasteboard].string = phoneStr;</span><br><span class="line">    &#125;</span><br><span class="line">    // 实现操作执行后应该实现的功能。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/09/cell_copy/" data-id="cjgeztz680004gwf91ijio5sq" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-APP_Process_Threads" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/01/APP_Process_Threads/" class="article-date">
  <time datetime="2018-02-28T16:00:00.000Z" itemprop="datePublished">2018-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/01/APP_Process_Threads/">iOS - 线程 / 进程 的通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-线程中的通信"><a href="#1-线程中的通信" class="headerlink" title="1. 线程中的通信"></a>1. 线程中的通信</h4><ul>
<li>线程中通信的体现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 .一个线程传递数据给另一个线程</span><br><span class="line">2 .在一个线程中执行完特定任务后，转到另一个线程继续执行任务</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在iOS多线程开发中，有NSThread、GCD、NSOpeartion几种方式，<br>对应的线程间通信</p>
<p>#####1.1 NSThread<br><code>NSThread可以先将自己的当前线程对象注册到某个全局的对象中去，这样相互之间就可以获取对方的线程对象，然后就可以使用下面的方法进行线程间的通信了，由于主线程比较特殊，所以框架直接提供了在主线程执行的方法</code></p>
<p>回到主线程执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  aSelector： 执行方法</span><br><span class="line"> *  arg: 携带参数</span><br><span class="line"> */</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br></pre></td></tr></table></figure></p>
<p>去指定线程执行任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *   aSelector： 执行方法</span><br><span class="line"> *   thr: 指定线程</span><br><span class="line"> *   arg: 携带参数</span><br><span class="line"> */</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait;</span><br></pre></td></tr></table></figure></p>
<p>关于 <strong>waitUntilDone</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">waitUntilDone的含义:</span><br><span class="line">如果传入的是YES: 那么会等到主线程中的方法执行完毕, 才会继续执行下面其他行的代码</span><br><span class="line">如果传入的是NO: 那么不用等到主线程中的方法执行完毕, 就可以继续执行下面其他行的代码</span><br></pre></td></tr></table></figure></p>
<p>#####1.2 GCD</p>
<ul>
<li><p>什么是GCD<br>全称是Grand Central Dispatch，可译为“牛逼的中枢调度器”<br>纯C语言，提供了非常多强大的函数</p>
</li>
<li><p>GCD的使用<br>GCD中有2个核心概念<br>（1）任务：执行什么操作<br>（2）队列：用来存放任务</p>
<p>GCD的使用就2个步骤<br>（1）定制任务<br>（2）确定想做的事情</p>
<p>将任务添加到队列中，GCD会自动将队列中的任务取出，放到对应的线程中执行<br>注意：任务的取出遵循队列的FIFO原则：先进先出，后进后出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  /*</span><br><span class="line">  * queue：队列</span><br><span class="line">  * block：任务 </span><br><span class="line">  */</span><br><span class="line">（1）用同步的方式执行任务 dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class="line">（2）用异步的方式执行任务 dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// queue 表示某个子线程</span><br><span class="line">dispatch_async(subQueue, ^&#123;</span><br><span class="line">        // 在子线程中</span><br><span class="line">  dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      #回到主线程</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>关于GCD 远远不止这些功能, 这里这是讲了最基本的简单通信. </p>
<p>#####1.3 NSOperation</p>
<ul>
<li><p>简介<br>NSOperation是基于GCD的，那么使用起来也和GCD差不多，其中，NSOperation相当于GCD中的任务，而NSOperationQueue则相当于GCD中的队列。</p>
</li>
<li><p>NSOperation实现多线程的使用步骤分为三步：<br>创建任务：先将需要执行的操作封装到一个NSOperation对象中。<br>创建队列：创建NSOperationQueue对象。<br>将任务加入到队列中：然后将NSOperation对象添加到NSOperationQueue中。</p>
</li>
<li><p>获取队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 主队列</span><br><span class="line">// 凡是添加到主队列中的任务（NSOperation），都会放到主线程中执行</span><br><span class="line">NSOperationQueue *queue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 其他队列（非主队列）</span><br><span class="line">// 添加到这种队列中的任务（NSOperation），就会自动放到子线程中执行</span><br><span class="line">// 同时包含了：串行、并发功能</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br></pre></td></tr></table></figure>
<ul>
<li>添加任务<br><code>- (void)addOperation:(NSOperation *)op</code><br>需要先创建任务，再将创建好的任务加入到创建好的队列中去<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建队列</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">// 2. 创建操作  </span><br><span class="line">// 创建NSInvocationOperation    </span><br><span class="line">NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(test) object:nil];    </span><br><span class="line">// 创建NSBlockOperation    </span><br><span class="line">NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">  NSLog(@&quot;op2 ---- %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3. 添加操作到队列中：addOperation:   </span><br><span class="line">[queue addOperation:op1]; // [op1 start]    </span><br><span class="line">[queue addOperation:op2]; // [op2 start]</span><br><span class="line"></span><br><span class="line">- (void)run&#123;</span><br><span class="line">  NSLog(@&quot;op1 ---- %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>- (void)addOperationWithBlock:(void (^)(void))block</code><br>无需先创建任务，在block中添加任务，直接将任务block加入到队列中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建队列</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">// 2. 添加操作到队列中：addOperationWithBlock:</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">  NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<ul>
<li>线程通信<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">  NSLog(@&quot;1 ---- %@&quot;, [NSThread currentThread]);</span><br><span class="line">  # 回到主线程</span><br><span class="line">  [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2 ---- %@&quot;, [NSThread currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>NSOperation 和GCD一样 不止以上这些功能，这里只是讲述了基本的使用和简单的线程通信.</p>
<p>####2.进程的通信<br>进程是容纳运行一个程序所需要所有信息的容器。在iOS中每个APP里就一个进程，所以进程间的通信实际上是APP之间的通信.</p>
<p>#####2.1 URL Scheme</p>
<ul>
<li><p>什么是URL Scheme<br>由于苹果的app都是在沙盒中，相互是不能访问数据的。但是苹果还是给出了一个可以在app之间跳转的方法：URL Scheme。简单的说，URL Scheme就是一个可以让app相互之间可以跳转的协议。每个app的URL Scheme都是不一样的，如果存在一样的URL Scheme，那么系统就会响应先安装那个app的URL Scheme，因为后安装的app的URL Scheme被覆盖掉了，是不能被调用的。</p>
</li>
<li><p>URL Scheme怎么使用<br>App1通过openURL的方法跳转到App2，并且在URL中带上想要的参数，有点类似http的get请求那样进行参数传递。</p>
</li>
</ul>
<p>源 APP1 的配置<br>源App1需要在info.plist中配置LSApplicationQueriesSchemes，指定目标App2的scheme<br><img src="http://upload-images.jianshu.io/upload_images/3111822-a373512510b93081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="源 APP1 的配置"></p>
<p>目标 APP2 的配置<br>然后在目标App2的info.plist中配置好URL types，表示该app接受何种URL scheme的唤起。<br><img src="http://upload-images.jianshu.io/upload_images/3111822-dcce91b08e42c437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目标 APP2 的配置"></p>
<p>也可以在 项目-&gt; info -&gt; URL types 中直接添加<br><img src="http://upload-images.jianshu.io/upload_images/3111822-29f215842f653328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置方法二"></p>
<p>源 APP1 的代码调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIApplication *application = [UIApplication sharedApplication];</span><br><span class="line">NSURL *URL = [NSURL URLWithString:@&quot;testApp2://hello,word&quot;];</span><br><span class="line">[application openURL:URL options:@&#123;&#125; completionHandler:nil];</span><br></pre></td></tr></table></figure></p>
<p>目标 APP2 的代码接收<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AppDelegate.m 中</span><br><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,url);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3111822-96a29b608cfdec57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打印结果"></p>
<p>#####2.2 UIPasteboard<br>UIPasteboard是剪切板功能，因为iOS的原生控件UITextView，UITextField 、UIWebView，我们在使用时如果长按，就会出现复制、剪切、选中、全选、粘贴等功能，这个就是利用了系统剪切板功能来实现的。而每一个App都可以去访问系统剪切板，所以就能够通过系统剪贴板进行App间的数据传输了。<br>UIPasteboard典型的使用场景就是淘宝的淘口令。</p>
<ul>
<li>使用<br>源APP赋值<br><code>[[UIPasteboard generalPasteboard] setString:@&quot;hello,word&quot;];</code><br>目标APP取值<br><code>NSString *value = [UIPasteboard generalPasteboard].string;</code></li>
</ul>
<p>#####2.3 Keychain</p>
<blockquote>
<p>Keychain是iOS中一个安全存储容器，本质是一个sqlite数据库，位置在/private/var/Keychains/keychain-2.db。它是独立于每个App的沙盒之外的，所以即使App被删除之后，Keychain里面的信息依然存在。基于安全和独立于app沙盒的两个特性，Keychain主要用于给app保存登录和身份凭证等敏感信息，这样只要用户登录过，即使用户删除了app重新安装也不需要重新登录。<br>Keychain用于App间通信的一个典型场景也和app的登录相关，就是统一账户登录平台。使用同一个账号平台的多个app，只要其中一个app用户进行了登录，其他app就可以实现自动登录不需要用户多次输入账号和密码。一般开放平台都会提供登录SDK，在这个SDK内部就可以把登录相关的信息都写到keychain中，这样如果多个app都集成了这个SDK，那么就可以实现统一账户登录了。</p>
</blockquote>
<p> <a href="https://www.jianshu.com/p/6bc772bdeece" target="_blank" rel="noopener">具体使用</a><br>目前我自己还不太熟悉这个框架的使用,后续了解清楚会补充该框架的本人理解及使用方法.</p>
<p>#####2.4 分享<br>通过将源APP数据分享给目标APP 实现通信<br>原生分享 </p>
<ul>
<li><p>UIActivityViewController(轻量级信息分享),</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Items: 元素1是标题，元素2是URL</span><br><span class="line">UIActivityViewController *avc = [[UIActivityViewController alloc]initWithActivityItems:@[@&quot;title&quot;,url] applicationActivities:nil];</span><br><span class="line">    </span><br><span class="line">[self presentViewController:avc animated:YES completion:nil];</span><br><span class="line">    </span><br><span class="line">//分享结果回调方法</span><br><span class="line">UIActivityViewControllerCompletionWithItemsHandler myblock = ^(NSString * __nullable activityType, BOOL completed, NSArray * __nullable returnedItems, NSError * __nullable activityError)&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">avc.completionWithItemsHandler = myblock;</span><br></pre></td></tr></table></figure>
</li>
<li><p>UIDocumentInteractionController (主要是共享文档，预览)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *urlStr = [[NSBundle mainBundle] pathForResource:@&quot;1.png&quot; ofType:nil];</span><br><span class="line">NSURL *url = [NSURL fileURLWithPath:urlStr];</span><br><span class="line">    </span><br><span class="line">UIDocumentInteractionController *documentVc = [UIDocumentInteractionController interactionControllerWithURL:url];</span><br><span class="line">documentVc.delegate = self;</span><br><span class="line"></span><br><span class="line">[documentVc presentPreviewAnimated:YES];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - UIDocumentInteractionController 代理方法</span><br><span class="line">// 预览的视图控制器</span><br><span class="line">- (UIViewController *)documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)controller&#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">// 父View</span><br><span class="line">- (UIView *)documentInteractionControllerViewForPreview:(UIDocumentInteractionController *)controller&#123;</span><br><span class="line">    return self.view;</span><br><span class="line">&#125;</span><br><span class="line">// 预览界面的尺寸</span><br><span class="line">- (CGRect)documentInteractionControllerRectForPreview:(UIDocumentInteractionController *)controller&#123;</span><br><span class="line">    return self.view.bounds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三方SDK分享</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/01/APP_Process_Threads/" data-id="cjgeztz5w0000gwf9hkkchpxq" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-WebKit_JS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/WebKit_JS/" class="article-date">
  <time datetime="2017-09-13T08:12:12.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/WebKit_JS/">WebKit与JS的简单交互</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###JS调OC</p>
<p>######OC中的实现<br>1.创建一个WKWebViewConfiguration<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WKWebViewConfiguration 是用来配置WKWebView的</span><br><span class="line">WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">configuration.userContentController = [WKUserContentController new];</span><br><span class="line"> // 注册一个处理事件 参数1:谁来响应这个操作事件(类似于代理，遵守 WKScriptMessageHandler 协议)  参数2: 操作唯一标识符</span><br><span class="line"> //[configuration.userContentController addScriptMessageHandler:self name:@&quot;操作的唯一标识&quot;]; </span><br><span class="line">[configuration.userContentController addScriptMessageHandler:self name:@&quot;testAction&quot;];</span><br></pre></td></tr></table></figure></p>
<p>2.创建一个WKWebView 与 WKWebViewConfiguration关联起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:configuration];  </span><br><span class="line">self.webView.backgroundColor = [UIColor whiteColor];</span><br><span class="line">[self.webView loadRequest:[NSURLRequest requestWithURL:@&quot;.........&quot;]]; </span><br><span class="line">[self.view addSubview:self.webView];</span><br></pre></td></tr></table></figure></p>
<ol>
<li>实现 WKScriptMessageHandler 协议中的 userContentController: didReceiveScriptMessage 方法来监听上述配置中的操作事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - WKScriptMessageHandler</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,message.name); // 注册操作事件时的唯一标示符</span><br><span class="line">    NSLog(@&quot;%@&quot;,message.body); // JS返回回来的数据</span><br><span class="line">    // 判定name来决定是哪个操作事件</span><br><span class="line">    if([message.name isEqualToString:@&quot;testAction&quot;])&#123;</span><br><span class="line">      NSLog(@&quot;testAction&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>4.使用结束后 确定该标识不需要用 需要删除 要不然会强引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[configuration.userContentController removeScriptMessageHandlerForName:@&quot;testAction&quot;];</span><br></pre></td></tr></table></figure></p>
<h6 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let configuration = WKWebViewConfiguration()</span><br><span class="line">configuration.userContentController = WKUserContentController()</span><br><span class="line">configuration.userContentController.add(self, name: &quot;testAction&quot;)</span><br><span class="line">        </span><br><span class="line">self.webView = WKWebView.init(frame: self.view.bounds, configuration: configuration)</span><br><span class="line">self.view.addSubview(self.webView)</span><br><span class="line">let url = URL(string: &quot;----&quot;)!</span><br><span class="line">self.webView.load(URLRequest(url: url))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) &#123;</span><br><span class="line">    print(message.name)</span><br><span class="line">    print(message.body)        </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用结束同样需要删除</span><br><span class="line">configuration.userContentController.removeScriptMessageHandler(forName: &quot;testAction&quot;)</span><br></pre></td></tr></table></figure>
<p>同样也是要遵守协议 WKScriptMessageHandler</p>
<p>######JS中的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在哪里需要调用OC 那么就在哪个函数中调用</span><br><span class="line">例:</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   function testAction() &#123;</span><br><span class="line">       &lt;!--window.webkit.messageHandlers.方法名(与注册的一致(message.name) ).postMessage(JS传下来的数据(message.body))--&gt;</span><br><span class="line">     &lt;!--data 可以是数组 字典 json字符串.....--&gt;</span><br><span class="line">       window.webkit.messageHandlers.testAction.postMessage(data)</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>###OC调JS</p>
<p>######OC中的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WKWebView中直接有方法可以调用</span><br><span class="line">// 字符串内容为:JS中的方法名(参数) 参数可以是数组 字典 json字符串</span><br><span class="line">NSString *jsStr = [NSString stringWithFormat:@&quot;showResult(&apos;10086&apos;)&quot;];</span><br><span class="line">[self.webView evaluateJavaScript:jsStr completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123;</span><br><span class="line">    NSLog(@&quot;%@----%@&quot;,result, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<h6 id="Swift-1"><a href="#Swift-1" class="headerlink" title="Swift"></a>Swift</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</span><br><span class="line">let js = &quot;showResult(\(arr))&quot;</span><br><span class="line">self.webView.evaluateJavaScript(js, completionHandler: &#123; (result, error) in</span><br><span class="line">    print(result ?? &quot;nil&quot;,error ?? &quot;nil&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>completionHandler 会调中的 result 是js方法的返回值 (result是个 <strong><em>id / Any</em></strong> 类型，也就是说js中可以返回任意值)</p>
<p>######JS中的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  function showResult(result) &#123;</span><br><span class="line">    alert(result)</span><br><span class="line">    return &quot;hello,word&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>###其他</p>
<h5 id="关于-JS中的alert弹框在WKWebView中无法弹出"><a href="#关于-JS中的alert弹框在WKWebView中无法弹出" class="headerlink" title="关于 JS中的alert弹框在WKWebView中无法弹出"></a>关于 JS中的alert弹框在WKWebView中无法弹出</h5><p>原生的alert弹框在WK上面无法弹出<br>解决方法 :<br><code>1. 不使用原生的alert, 自定义一个弹框</code></p>
<p><code>2. 遵守WKUIDelegate  实现WKWebView的UIDelegate</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 显示一个按钮。点击后调用completionHandler回调</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler&#123;</span><br><span class="line">    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:message?:@&quot;&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    [alertController addAction:([UIAlertAction actionWithTitle:@&quot;确认&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        completionHandler();</span><br><span class="line">    &#125;])];</span><br><span class="line">    [self presentViewController:alertController animated:YES completion:nil];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 显示两个按钮，通过completionHandler回调判断用户点击的确定还是取消按钮</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler&#123;</span><br><span class="line">    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:message?:@&quot;&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    [alertController addAction:([UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        completionHandler(NO);</span><br><span class="line">    &#125;])];</span><br><span class="line">    [alertController addAction:([UIAlertAction actionWithTitle:@&quot;确认&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        completionHandler(YES);</span><br><span class="line">    &#125;])];</span><br><span class="line">    [self presentViewController:alertController animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 显示一个带有输入框和一个确定按钮的，通过completionHandler回调用户输入的内容</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable))completionHandler&#123;</span><br><span class="line">    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:prompt message:@&quot;&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    [alertController addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123;</span><br><span class="line">        textField.text = defaultText;</span><br><span class="line">    &#125;];</span><br><span class="line">    [alertController addAction:([UIAlertAction actionWithTitle:@&quot;完成&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">        completionHandler(alertController.textFields[0].text?:@&quot;&quot;);</span><br><span class="line">    &#125;])];</span><br><span class="line">    </span><br><span class="line">    [self presentViewController:alertController animated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相当于是系统在检测到alert弹框时，会调用这些代理方法，然后通过代理方法把对应参数告诉我们，我们自己实现alert方法来弹框</p>
<h5 id="关于-JS中的select下拉框在WKWebView中的显示样式"><a href="#关于-JS中的select下拉框在WKWebView中的显示样式" class="headerlink" title="关于 JS中的select下拉框在WKWebView中的显示样式"></a>关于 JS中的select下拉框在WKWebView中的显示样式</h5><p>js 中 select 下拉框在不同的浏览器显示的样式就不一样，在WKWebView中会已UIPickerView的形式展示，如果无法满足需求，需要自定义下拉框</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/13/WebKit_JS/" data-id="cjgeztz600002gwf96448qofi" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/25/iOS - 人脸特征关键点获取/">iOS - 人脸特征关键点获取</a>
          </li>
        
          <li>
            <a href="/2018/03/09/cell_copy/">Cell自带的长按复制</a>
          </li>
        
          <li>
            <a href="/2018/03/01/APP_Process_Threads/">iOS - 线程 / 进程 的通信</a>
          </li>
        
          <li>
            <a href="/2017/09/13/WebKit_JS/">WebKit与JS的简单交互</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 wuliangwang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>